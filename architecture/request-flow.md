# Request Flow Design

(API → Dispatcher → Engine → Agent)

---

## 왜 이걸 다루는가 (문제 정의)

AI Agent 기반 시스템을 설계하면서  
**요청을 어떻게 흘려보낼 것인가**는 단순 구현 문제가 아니라  
시스템 전체의 **확장성, 안정성, 유지보수성**을 좌우하는 구조적 문제라고 판단했다.

이 프로젝트는 다음과 같은 특성을 가진다.

- 입력 형태가 고정되지 않음 (text, vision, rag, metadata 등)
- 기능이 점진적으로 추가될 예정
- 멀티 에이전트 / 멀티 파이프라인 구조

이러한 조건에서 요청 흐름에 대한  
**아키텍처적 구조 정의가 명확하지 않으면**,  
코드가 많이 쌓였을 때 구조를 수습하지 못할 가능성이 크다고 느꼈다.

그래서 이 문제를 **초기 설계 단계에서 명시적으로 다루기로 결정했다.**

---

## 이 문제가 왜 중요하다고 판단했는지

요청 처리 흐름이 명확하지 않으면 다음과 같은 문제가 발생한다.

- 요청 분기 로직이 API, Engine, Agent에 흩어짐
- 새로운 기능 추가 시 if/else 분기가 급격히 증가  
  (변경 지점이 분산되어 수정 난이도가 높아짐)
- 코드 수정 시 영향 범위를 예측하기 어려움

이는 단순한 코드 스타일 문제가 아니라  
**변경 비용이 기하급수적으로 증가하는 구조적 문제**로 이어진다.

이러한 문제는 초기에 다루지 않으면  
나중에 되돌리기 매우 어려운 기술 부채가 된다고 판단했다.

---

## 해결하지 않으면 어떤 한계가 생기는지

- 요청 타입이 늘어날수록 중복 분기 로직이 증가
- Agent가 요청 구조를 과도하게 알게 됨
- 테스트 단위가 명확하지 않아 테스트 복잡도 증가
- 디버깅 시 요청 흐름 추적이 어려워짐

결과적으로  
**구조를 이해한 사람만 수정할 수 있는 코드**가 될 위험이 있다.

번외로,  
프론트엔드에서 컴포넌트 단위로 책임을 나누며 설계했던 경험이 있는데,  
이 경험이 이번 구조를 고민하는 데 큰 도움이 되었다.

---

## 처음 생각 (초기 가설)

초기에는 다음과 같은 직관적인 가설을 가졌다.

- 개인 프로젝트이므로 구조를 단순하게 가져가도 된다
- API에서 바로 Agent를 호출해도 문제없다
- Dispatcher 같은 계층은 나중에 추가해도 된다

즉,  
`API → Agent`  
와 같은 직선 구조로도 충분하다고 생각했다.

이 방식은 구현 속도가 빠르고  
초기 실험에는 유리해 보였다.

다만, 개발을 빠르게 시작하는 것보다  
**구조적으로 단단한 기반을 먼저 잡는 것이 더 중요하다는 판단**이 들었다.

---

## 시도 / 비교 (고려했던 선택지들)

### 선택지 1) API → Agent

**장점**

- 구현이 빠르고 단순함
- 초기 실험에 적합

**단점**

- 요청 검증, 분기, 흐름 제어가 API에 집중됨
- Agent가 요청 구조에 강하게 결합됨
- Vision / RAG 추가 시 API 코드가 급격히 비대해짐

---

### 선택지 2) API → Engine → Agent

**장점**

- API 레이어가 얇아짐
- 흐름을 한 곳에서 관리 가능

**단점**

- Engine이 분기와 실행을 동시에 책임
- Engine의 복잡도가 빠르게 증가
- Body Type 증가 시 유지보수 부담이 커짐

---

### 선택지 3) API → Dispatcher → Engine → Agent (최종 선택)

**장점**

- 각 계층의 책임이 명확함
  - API: 요청 검증 (이 요청은 유효한가?)
  - Dispatcher: 경로 결정 (어디로 보낼 것인가?)
  - Engine: 흐름 오케스트레이션 (어떤 순서로 실행할 것인가?)
  - Agent: 사고 및 판단 (어떻게 처리할 것인가?)
- 확장 시 기존 코드에 미치는 영향 최소화
- 테스트, 로깅, 디버깅 단위가 명확해짐

**단점**

- 초기 구조가 다소 많아 보일 수 있음
- 개인 프로젝트 기준에서는 과설계처럼 느껴질 수 있음

---

## 깨진 지점 (예상과 달랐던 부분)

Dispatcher를 분리하지 않으면  
Engine이 예상보다 빠르게 비대해진다는 점이 의외였다.

또한  
“나중에 분리하면 된다”는 판단이  
실제로는 거의 불가능하다는 것도 체감했다.

---

## 현재 판단 (지금 시점의 결론)

`API → Dispatcher → Engine → Agent` 구조는  
지금 당장 필요한 기능을 위한 설계라기보다  
**미래의 변경 비용을 최소화하기 위한 설계**라고 판단한다.

계층을 더 세분화하는 방향도 고민했지만,  
단순히 쪼갠다고 해서 책임이 분리되는 것은 아니며  
오히려 질문이 중복되고 수정 지점이 늘어날 수 있다고 보았다.

비동기 처리, 병렬 실행, 워크플로우 관리 등  
**새로운 유형의 문제가 실제로 등장할 경우에만**  
추가적인 계층 분리를 고려하는 것이 합리적이라고 판단했다.

- Dispatcher는 초기 기준으로 존재만 선언
- 실제 분기 로직은 이후 점진적으로 구현
- Agent 인터페이스는 가장 마지막에 확정

이 순서가  
과설계를 피하면서도 구조 붕괴를 막는  
가장 현실적인 균형점이라고 본다.

---

## 임시 결론인 이유

아직 다음과 같은 상황을 충분히 겪지는 않았다.

- 실제 트래픽 증가
- 복잡한 Vision / RAG 파이프라인
- 다중 Agent 협업 시나리오

따라서 이 구조는  
**가설 기반의 합리적 선택**이며,  
절대적인 정답이라고 단정하지는 않는다.

---

## 남은 질문

- Dispatcher가 단순 분기를 넘어  
  전략 선택자 역할까지 맡아야 할까?
- Body Type이 4개 이상으로 늘어날 경우  
  이 구조는 계속 유지 가능한가?
- 구현이 진행되며 특정 계층의 책임이 과도해질 경우  
  구조적으로 어떻게 분리하는 것이 적절할까?

---

## 다음 단계에서 검증할 것

- Dispatcher 실제 구현 후 복잡도 측정
- Engine.run()에 로깅 / 에러 핸들링 추가
- Vision / RAG 연결 후 구조 스트레스 테스트

필요하다면  
구조가 과도하다고 판단되는 시점에서  
과감한 단순화도 고려할 예정이다.

---

### 개인 메모

이 구조는  
“지금 편하려고 만든 선택”이 아니라  
**나중에 안 무너지게 하려고 만든 선택**이다.
